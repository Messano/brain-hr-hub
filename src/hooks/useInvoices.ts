import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

export type InvoiceStatus = "draft" | "pending" | "sent" | "paid" | "cancelled";

export interface Invoice {
  id: string;
  invoice_number: string;
  client_id: string;
  period_start: string;
  period_end: string;
  total_ht: number;
  total_tva: number;
  total_ttc: number;
  status: InvoiceStatus;
  issue_date: string;
  due_date: string | null;
  payment_date: string | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
}

export interface InvoiceLine {
  id: string;
  invoice_id: string;
  contract_id: string | null;
  personnel_id: string | null;
  heures_normales: number;
  heures_sup_25: number;
  heures_sup_50: number;
  heures_sup_100: number;
  heures_feriees: number;
  indemnites_soumises: number;
  indemnites_non_soumises: number;
  conge_paye: number;
  prime: number;
  montant_ht: number;
  description: string | null;
  created_at: string;
}

export type InvoiceWithClient = Invoice & {
  clients: { id: string; raison_sociale: string; code: string; tva: string | null } | null;
};

export type InvoiceLineWithPersonnel = InvoiceLine & {
  personnel: { id: string; nom: string; prenom: string; matricule: string } | null;
  contracts: { id: string; numero_contrat: string; taux_horaire: number | null } | null;
};

export function useInvoices() {
  return useQuery({
    queryKey: ["invoices"],
    queryFn: async () => {
      const { data, error } = await supabase
        .from("invoices")
        .select("*, clients(id, raison_sociale, code, tva)")
        .order("created_at", { ascending: false });

      if (error) throw error;
      return data as InvoiceWithClient[];
    },
  });
}

export function useInvoice(id: string | undefined) {
  return useQuery({
    queryKey: ["invoices", id],
    queryFn: async () => {
      if (!id) return null;
      const { data, error } = await supabase
        .from("invoices")
        .select(`*, clients(
          id, raison_sociale, code, tva, code_ice, adresse_facturation, 
          delai_reglement, mode_reglement,
          coef_heures_normales, coef_heures_sup_25, coef_heures_sup_50, 
          coef_heures_sup_100, coef_heures_feriees, coef_indemnites_soumises,
          coef_indemnites_non_soumises, coef_conge_paye, coef_prime
        )`)
        .eq("id", id)
        .maybeSingle();

      if (error) throw error;
      return data as InvoiceWithClient & {
        clients: {
          id: string;
          raison_sociale: string;
          code: string;
          tva: string | null;
          code_ice: string | null;
          adresse_facturation: string | null;
          delai_reglement: number | null;
          mode_reglement: string | null;
          coef_heures_normales: number | null;
          coef_heures_sup_25: number | null;
          coef_heures_sup_50: number | null;
          coef_heures_sup_100: number | null;
          coef_heures_feriees: number | null;
          coef_indemnites_soumises: number | null;
          coef_indemnites_non_soumises: number | null;
          coef_conge_paye: number | null;
          coef_prime: number | null;
        } | null;
      };
    },
    enabled: !!id,
  });
}

export function useInvoiceLines(invoiceId: string | undefined) {
  return useQuery({
    queryKey: ["invoice-lines", invoiceId],
    queryFn: async () => {
      if (!invoiceId) return [];
      const { data, error } = await supabase
        .from("invoice_lines")
        .select("*, personnel(id, nom, prenom, matricule), contracts(id, numero_contrat, taux_horaire)")
        .eq("invoice_id", invoiceId)
        .order("created_at", { ascending: true });

      if (error) throw error;
      return data as InvoiceLineWithPersonnel[];
    },
    enabled: !!invoiceId,
  });
}

export interface InvoiceInsert {
  client_id: string;
  period_start: string;
  period_end: string;
  total_ht: number;
  total_tva: number;
  total_ttc: number;
  status?: InvoiceStatus;
  issue_date: string;
  due_date?: string | null;
  notes?: string | null;
}

export function useCreateInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (invoice: InvoiceInsert) => {
      // invoice_number is auto-generated by the database trigger
      const insertData = {
        ...invoice,
        invoice_number: "", // Will be overwritten by trigger
      };
      const { data, error } = await supabase
        .from("invoices")
        .insert(insertData)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["invoices"] });
      toast.success("Facture créée avec succès");
    },
    onError: (error) => {
      toast.error("Erreur lors de la création: " + error.message);
    },
  });
}

export function useUpdateInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, ...invoice }: Partial<Invoice> & { id: string }) => {
      const { data, error } = await supabase
        .from("invoices")
        .update(invoice)
        .eq("id", id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["invoices"] });
      toast.success("Facture mise à jour avec succès");
    },
    onError: (error) => {
      toast.error("Erreur lors de la mise à jour: " + error.message);
    },
  });
}

export function useDeleteInvoice() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase.from("invoices").delete().eq("id", id);
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["invoices"] });
      toast.success("Facture supprimée avec succès");
    },
    onError: (error) => {
      toast.error("Erreur lors de la suppression: " + error.message);
    },
  });
}

export function useCreateInvoiceLine() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (line: Omit<InvoiceLine, "id" | "created_at">) => {
      const { data, error } = await supabase
        .from("invoice_lines")
        .insert(line)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ["invoice-lines", variables.invoice_id] });
      toast.success("Ligne ajoutée avec succès");
    },
    onError: (error) => {
      toast.error("Erreur lors de l'ajout: " + error.message);
    },
  });
}

export function useDeleteInvoiceLine() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, invoiceId }: { id: string; invoiceId: string }) => {
      const { error } = await supabase.from("invoice_lines").delete().eq("id", id);
      if (error) throw error;
      return invoiceId;
    },
    onSuccess: (invoiceId) => {
      queryClient.invalidateQueries({ queryKey: ["invoice-lines", invoiceId] });
      toast.success("Ligne supprimée avec succès");
    },
    onError: (error) => {
      toast.error("Erreur lors de la suppression: " + error.message);
    },
  });
}

export function useInvoiceStats() {
  return useQuery({
    queryKey: ["invoice-stats"],
    queryFn: async () => {
      const { data, error } = await supabase.from("invoices").select("*");
      if (error) throw error;

      const total = data.length;
      const draft = data.filter((i) => i.status === "draft").length;
      const pending = data.filter((i) => i.status === "pending").length;
      const sent = data.filter((i) => i.status === "sent").length;
      const paid = data.filter((i) => i.status === "paid").length;
      const totalHT = data.reduce((sum, i) => sum + Number(i.total_ht || 0), 0);
      const totalTTC = data.reduce((sum, i) => sum + Number(i.total_ttc || 0), 0);

      return { total, draft, pending, sent, paid, totalHT, totalTTC };
    },
  });
}
